package lang.collections.basics;

public class C_Hashcode {

    public static void main(String[] args) {

        /*

            Purpose of Hash code:
            For Collections, it is an easy way to look up for an element

            Finding an object in a collection:
            Finding the hash

            Link: https://www.baeldung.com/java-hashcode

            For some collections such as HashMap, HashSet, etc., these collections make use of the hashCode() of the
            objects which are being stored in them. With the help of hash code they store it efficiently and retrieve
            them in < linear time.

            For collections to work properly, the below contract is essential.
            Simply put, hashCode() returns an integer value, generated by a hashing algorithm.
            Objects that are equal (according to their equals()) must return the same hash code. Different objects do
            not need to return different hash codes.

            EQUALS HASH CODE CONTRACT in detail
            1. If two objects are equal according to the equals(Object) method, calling the hashCode() method on each
               of the two objects must produce the same value.
            2. If two objects are unequal according to the equals(java.lang.Object) method, calling the hashCode method
               on each of the two objects does not need to produce distinct integer results. However, developers should be
               aware that producing distinct integer results for unequal objects improves the performance of hash tables.
            3. Whenever it is invoked on the same object more than once during an execution of a Java application, hashCode()
               must consistently return the same value, provided no information used in equals comparisons on the object
               is modified. This value does not need to stay consistent from one execution of an application to another
               execution of the same application.

            hashCode() method is also a part of the Object class similar to equals()

            The default implementation of hashCode() method in Object class gives the hash(reference) where object is
            located. So, by default if two variables are pointing the same object they would have same hash code.

            Hash Code Options:
            * Default - generates a hash code based on the memory address
            Analogy would be similar to equals
            BasicPerson p1 = new BasicPerson(1, "Sai", 24);
            BasicPerson p2 = p1;
            p1.hashCode() == p2.hashCode(); // returns true

            But, similar to equals(), the default implementation would not work for cases like:
            BasicPerson p1 = new BasicPerson(1, "Sai", 24);
            BasicPerson p2 = new BasicPerson(1, "Sai", 24);
            p1.hashCode() == p2.hashCode(); // returns false

            The above returns false because they are two separate instances, and we know the default hashCode() returns a
            hash code of reference which is different for two objects as they are separate instances.

            Assume you have added p1 to hashSet, and now you want to check if p2 is present in hashSet or not so that you can add
            p2 to hashSet. The hashSet's contains() method takes p2 and it calls hashCode() of p2 and hashCode of every element
            in hashSet. Now when it compares hash code of p1 and p2, they will be different because they are different instances,
            hence hashSet thinks this is not present in it and add it. But ideally p1 and p2 are same Object wise.

            To overcome this, we should override hashCode() method of Object class in such a way that, when two objects are
            equal according to the equals() method, they should have same hashCode()

            Standard hashCode() implementation:
            The better the hashing algorithm that we use to compute hash codes, the better the performance of hash tables. Let’s have a
            look at a “standard” implementation that uses two prime numbers to add even more uniqueness to computed hash codes:

            @Override
            public int hashCode() {
                int hash = 7;
                hash = 31 * hash + (int) id;
                hash = 31 * hash + (name == null ? 0 : name.hashCode());
                hash = 31 * hash + (email == null ? 0 : email.hashCode());
                return hash;
            }

            While we need to understand the roles that hashCode() and equals() methods play, we don’t have to implement them from
            scratch every time. This is because most IDEs can generate custom hashCode() and equals() implementations. And since
            Java 7, we have an Objects.hash() utility method for comfortable hashing:

            Objects.hash(name, email)

            So, we can simply use the above to get hash code for an object of a class.
        */

    }
}
